\documentclass{beamer}
\usetheme{Copenhagen}

\title{Learning with Error and GSW's Homomorphic Encryption}

\begin{document}

\frame{
	\titlepage
}

\frame{
	\frametitle{Intuition of LWE}
	$$14s_1+15s_2+5s_3+2s_4\approx8\pmod{17}$$
	$$13s_1+14s_2+14s_3+6s_4\approx16\pmod{17}$$
	$$6s_1+10s_2+13s_3+s_4\approx3\pmod{17}$$
	$$10s_1+4s_2+12s_3+16s_4\approx12\pmod{17}$$
	$$9s_1+5s_2+9s_3+6s_4\approx9\pmod{17}$$
	$$3s_1+6s_2+4s_3+5s_4\approx16\pmod{17}$$
	$$\vdots$$
	$$6s_1+7s_2+16s_3+2s_4\approx3\pmod{17}$$
}

\frame{
	\frametitle{Definition (LWE Distribution)}
	Let $A_{\vec{s}, \chi}$ be a distribution on
	$\mathbb{Z}^n_q\times\mathbb{Z}_q$ as follows:
	\pause
	\begin{itemize}[<+->]
		\item Pick $\vec{a}\in\mathbb{Z}^n_q$ uniformly randomly
		\item Pick $e$ according to $\chi$
		\item Output $(\vec{a}, \langle\vec{a}, \vec{s}\rangle + e)$
	\end{itemize}
}

\frame{
	\frametitle{Definition (LWE problem)}
	Given samples from $A_{\vec{s}, \chi}$,
	\begin{itemize}[<+->]
		\item Search version: Find $\vec{s}$.
		\item Decision version: Distinguish between $A_{\vec{s}, \chi}$
			and the uniform distribution.
	\end{itemize}
}


\frame{
	\frametitle{Search to decision reduction}
	\begin{itemize}[<+->]
		\item Assuming $q\in O(poly(n))$ is prime
		\item Inductive process; solve variable-by-variable
		\item Take $k$, a guess for $s_1$
		\item Pick $r$ uniformly at random
		\item Map $(\vec{a}, b)$ to $(\vec{a}+(r,0,0,\ldots,0), b+rk)$
		\item The above maps $A_{\vec{s},\chi}$ to itself if $k=s_1$,
			and to the uniform distribution otherwise.
		\item Check using the blackbox for decision version.
			Try another $k$ until the guess is correct.
	\end{itemize}
}

\frame{
	\frametitle{GSW's LWE formulation}
	\begin{itemize}[<+->]
		\item Redefine $\vec{a}_i$ as $b_i||\vec{a}_i$
		\item Redefine $\vec{s}$ as $(1,-\vec{s})$
		\item $A\vec{s}=\vec{e}$,
	\end{itemize}
	\pause[thebeamerpauses]
	Supposedly very hard problem
}

\frame{
	\frametitle{Asymmetric cryptography}
	Two parties who may have never communicated before may securely
	exchange information, by using the tools below:
	\pause
	\begin{itemize}[<+->]
		\item $pk$: ``public key", used for encryption
		\item $\textnormal{Enc}_{pk}:\Sigma^*\times\mathcal{R}\rightarrow U$
		\item $sk$: ``secret key", used for decryption
		\item $\textnormal{Dec}_{sk}:U\rightarrow\Sigma^*$.
		\item $\textnormal{Dec}_{sk}\circ\textnormal{Enc}_{pk}(x, r)=x$
			with overwhelming probability over $r$
	\end{itemize}
}

\frame{
	Typical use of such a scheme:
	\frametitle{Asymmetric cryptography cont.}
	\begin{enumerate}[<+->]
		\item Alice generates $(pk, sk)$
		\item Alice sends $pk$ to Bob
		\item Bob encrypts his message using $pk$
		\item Bob sends the ciphertext to Alice
		\item Alice decrypts it using $sk$
	\end{enumerate}
}

\frame{
	\frametitle{Security}
	What does it mean for an encryption scheme to be secure?
	\pause
	\begin{itemize}[<+->]
		\item Chosen plaintext attack (CPA): The "intuitive" definition.
			An (efficient) adversary who's able to encrypt anything shouldn't
			be able to decrypt anything.
		\item Adaptive chosen-ciphertext attack (CCA2):
			A stronger definition. An (efficient) adversary who's also able to
			decrypt anything but the target, still cannot decrypt the target.
	\end{itemize}
}

\frame{
	\frametitle{Homomorphic encryption}
	\begin{itemize}[<+->]
		\item TODO
		\item TODO
	\end{itemize}
}

\frame{
	\frametitle{Idea of GSW's homomorphic encryption}
	Intuitive idea as follows:
	\begin{itemize}[<+->]
		\item private key $\vec{v}$ is a vector
		\item ciphertexts are matrices with $\vec{v}$ approximately as an
			eigenvector
		\item plaintexts are corresponding approximate eigenvalues
		\item $(C_1+C_2)\vec{v}\approx(\lambda_1+\lambda_2)\vec{v}$
		\item $(C_1C_2)\vec{v}\approx(\lambda_1\lambda_2)\vec{v}$
		\item When plaintexts are booleans, $I_N-C_1C_2$ encodes NAND.
	\end{itemize}
}

\frame{
	\frametitle{GSW's tools}
	Define the following functions on $\mathbb{Z}_q^*$.
	Easier to understand with examples. Take $q=2^4$.
	\pause
	\begin{itemize}[<+->]
		\item $\textnormal{Powersof2}(1_2, 0_2, 11_2)=
			(1_2, 10_2, 100_2, 1000_2,
			0_2, 0_2, 0_2, 0_2,
			11_2, 110_2, 1100_2, 1000_2)$
		\item $\textnormal{BitDecomp}(1001_2, 0010_2, 1100_2)
			=(1,0,0,1,0,0,1,0,1,1,0,0)$
		\item $\textnormal{BitDecomp}^{-1}(1,0,0,1,0,0,1,0,1,1,0,0)
			=(1001_2, 0010_2, 1100_2)$
		\item $\textnormal{BitDecomp}^{-1}(0,0,10_2,0,0,1,10_2,1,11_2,0,1,1)
			=(0100_2, 1001_2, 1011_2)$
		\item $\textnormal{Flatten}=\textnormal{BitDecomp}\circ
			\textnormal{BitDecomp}^{-1}$
	\end{itemize}
}

\frame{
	\frametitle{GSW's tools (Flatten)}
		\begin{align*}
			\textnormal{Flatten}(&110_2, 101_2, 1_2, 11_2,\\
				&110_2, 101_2, 1_2, 11_2,\\
				&110_2, 101_2, 1_2, 11_2)
		\end{align*}
		\pause
		\begin{align*}
		=\textnormal{BitDecomp}\circ
			\textnormal{BitDecomp}^{-1}(&110_2, 101_2, 1_2, 11_2,\\
			&110_2, 101_2, 1_2, 11_2,\\
			&110_2, 101_2, 1_2, 11_2)
		\end{align*}
		\pause
		\begin{align*}
			=\textnormal{BitDecomp}(
			&110000_2+10100_2+10_2+11_2,\\
			&110000_2+10100_2+10_2+11_2,\\
			&110000_2+10100_2+10_2+11_2)
		\end{align*}
}

\frame{
	\frametitle{GSW's tools (Flatten)}
	\begin{align*}
		=\textnormal{BitDecomp}(&1001001_2,\\
		&1001001_2,\\
		&1001001_2)
	\end{align*}
	\pause
	\begin{align*}
	=\textnormal{BitDecomp}(1001_2, 1001_2, 1001_2)
	\end{align*}
	\pause
	\begin{align*}
	=(1,0,0,1,1,0,0,1,1,0,0,1)
	\end{align*}
}

\frame{
	\frametitle{GSW's tools cont.}
	Some basic properties
	\begin{itemize}[<+->]
		\item $\langle\textnormal{BitDecomp}(\vec{a}),
			\textnormal{Powersof2}(\vec{b})\rangle
			=\langle\vec{a},\vec{b}\rangle$
		\item $\langle\vec{a},\textnormal{Powersof2}(\vec{b})\rangle
			=\langle\textnormal{BitDecomp}^{-1}(\vec{a}),\vec{b}\rangle$
		\item $=\langle\textnormal{Flatten}(\vec{a}),
			\textnormal{Powersof2}(\vec{b})\rangle$
	\end{itemize}
}

\frame{
	\frametitle{GSW's Construction - Setup}
	Choose the following parameters:
	\begin{itemize}[<+->]
		\item Modulus $q=2^l$ (to simplify some proofs)
		\item Lattice dimension $n$
		\item Error distribution $\chi(\lambda, L)$
		\item $m\in O(n\log q)$
	\end{itemize}
}

\frame{
	\frametitle{GSW's Construction - Secret Keygen}
	\begin{enumerate}[<+->]
		\item Sample $\vec{s}\leftarrow\mathbb{Z}^n_q$ uniformly.
			This represents the solution of the LWE system of equations.
		\item Output $sk$ as $1$ on the first coordinate,
			followed by $-\vec{s}$.
	\end{enumerate}
}

\frame{
	\frametitle{GSW's Construction - Public Keygen}
	\begin{enumerate}[<+->]
		\item Generate $B\leftarrow\mathbb{Z}^{m\times n}_q$ uniformly
		\item Sample $\vec{e}\leftarrow\chi^m$
		\item Set $pk$ as $B\vec{s}+\vec{e}$ on the first column,
			followed by the columns of $B$.
		\item Observe that $pk\cdot sk=\vec{e}$
	\end{enumerate}
}

\frame{
	\frametitle{GSW's Construction - Encryption}
	Input: $\mu$
	\begin{enumerate}[<+->]
		\item Sample $R\in\{0, 1\}^{N\times m}$
		\item Output $\textnormal{Flatten}(
			\mu\cdot I+\textnormal{BitDecomp}(R\cdot pk))$
	\end{enumerate}
}

\frame{
	\frametitle{GSW's Construction - Decryption}
	$\textnormal{Flatten}(
			\mu\cdot I+\textnormal{BitDecomp}(R\cdot pk))
			\cdot\textnormal{Powersof2}(sk)$
	\pause
	$=(\mu\cdot I+\textnormal{BitDecomp}(R\cdot pk))
			\cdot\textnormal{Powersof2}(sk)$
	\pause
	$=\mu\textnormal{Powersof2}(sk) + R\cdot pk\cdot sk$
}

\frame{
	\frametitle{GSW's Construction - Decryption cont.}
	$\mu\textnormal{Powersof2}(sk) + R\cdot pk\cdot sk$
	\begin{itemize}[<+->]
		\item The second term is small.
		\item The first coordinate of $sk$ is $1$.
		\item $\Rightarrow$ The first coordinates of 
			$\mu\textnormal{Powersof2}(sk) + R\cdot pk\cdot sk$
			are $\approx\mu, 2\mu, \ldots, 2^{l-2}\mu, 2^{l-1}\mu$
		\item Recover $\mu$'s least significant bit by $LSB(\mu)=2^{l-1}\mu$
		\item Recover $\mu$'s next bit by $2^{l-2}(\mu-LSB(\mu))$
		\item Similar for all other bits of $\mu$.
		\item Decryption breaks down when the error reaches $q/4$.
	\end{itemize}
}

\frame{
	\frametitle{GSW's Construction - Security}
	\begin{itemize}[<+->]
		\item If $C=\textnormal{Enc}_{pk}(\mu, r)$ hides $\mu$, so does
			$\textnormal{BitDecomp}^{-1}(C)$, since $C$ can be derived from
			it.
		\item $\textnormal{BitDecomp}^{-1}(C)
			=\mu\cdot\textnormal{BitDecomp}^{-1}(I)+R\cdot A$
		\item Fact: The joint distribution $(A, R\cdot A)$ is
			indistinguishable from uniform, if $m>2nl$
	\end{itemize}
}

\frame{
	\frametitle{GSW's Construction - NAND}
	\begin{itemize}[<+->]
		\item $(I-C_1\cdot C_2)\vec{v}
			=(1-\mu_1\mu_2)\vec{v}-\mu_2\vec{e}_1-C_1\vec{e}_2$
		\item Error increased by a factor of $N+1$.
		\item Final error increase by a factor of $(N+1)^L$
	\end{itemize}
}

\frame{
	\frametitle{GSW's Construction - Multiplying by constant}
	Input: $C, \alpha$
	\begin{itemize}[<+->]
		\item Set $M_\alpha=\textnormal{Flatten}(\alpha I)$	
		\item Output $\textnormal{Flatten}(M_\alpha\cdot C)$
		\item Observe $M_\alpha\cdot C\vec{v}
			=M_\alpha\cdot(\mu\vec{v}+\vec{e})
			=\alpha\mu\vec{v}+M_\alpha\cdot{e}$
		\item Error increases by a factor of $N$
	\end{itemize}
}

\frame{
	\frametitle{GSW's Construction - Addition}
	\begin{itemize}[<+->]
		\item Simply add the ciphertexts
		\item Error increases by a factor of 2
	\end{itemize}
}

\frame{
	\frametitle{GSW's Construction - Multiplication}
	\begin{itemize}[<+->]
		\item $C_1\cdot C_2\vec{v}=C_1(\mu_2\vec{v}+\vec{e}_2)
			=\mu_1\mu_2\vec{v}+\mu_2\vec{e}_1+C_1\vec{e}_2$
		\item Error increase depends on what's being encrypted
		\item May need to assume bounds on the values being computed
	\end{itemize}
}

\frame{
	\frametitle{References}
	\begin{itemize}
		\item O. Regev. The Learning with Errors Problem.
		\item C. Gentry, A. Sahai, B. Waters.
			Homomorphic Encryption from Learning with Errors:
			Conceptually-Simpler, Asymptotically-Faster, Attribute-Based.
	\end{itemize}
}

\end{document}
